import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import calendar


def explore_outliers(dataframe, column, number_of_bins, positive=True, negative=True):
    """
    This function generates a histogram of the specified column from the given dataframe,
    visualizing the distribution of the data and marking the lower and upper whiskers
    based on the interquartile Range (IQR). It also annotates the frequency count for
    each bin and displays the whisker lines to help identify potential outliers. The
    function is extremely useful for preventing the total removal of outliers based
    solely on whisker values. The histogram generated by the function aids in
    identifying a more appropriate upper or lower whisker than the corresponding
    whiskers calculated from the IQR.

    For this reason, the final histogram displays not only the upper and lower whiskers
    but also the observation count for each bin. A dramatic reduction in observations
    between bins located outside the whiskers may indicate a more accurate limit
    between outliers and normal values. By combining all of the above with the display
    of the histogramâ€™s x-axis ticks on the bin edges, the function provides a robust
    method for determining the final value limit between outliers and normal values.

    TIP: Rerunning the function while changing the number_of_bins further enhances
    the identification of the true limit between outliers and normal values.

    Parameters:
    ----------
    dataframe : pandas.DataFrame
        The DataFrame containing the data.

    column : str
        The name of the column in the dataframe to analyze for outliers.

    number_of_bins : int
        The number of bins to use for the histogram.

    positive : bool, optional, default=True
        If True, the upper whisker (representing the 75th percentile + 1.5 * IQR) is shown.
        If False, the upper whisker is set to 0.

    negative : bool, optional, default=True
        If True, the lower whisker (representing the 25th percentile - 1.5 * IQR) is shown.
        If False, the lower whisker is set to 0.

    Returns:
    -------
    None
        Displays the histogram and whisker lines with annotations, but does not return any values.
    """

    # Calculate quartiles and IQR
    q1 = dataframe[column].quantile(q=0.25)
    q3 = dataframe[column].quantile(q=0.75)
    iqr = q3 - q1

    # Calculate the lower and upper whiskers
    lower_whisker = q1 - 1.5 * iqr
    upper_whisker = q3 + 1.5 * iqr

    # Set up figure:
    plt.figure(figsize=(12, 8), dpi=150)

    # Create the histogram:
    image = sns.histplot(dataframe[column], bins=number_of_bins)

    # Count the histogram bin counts and edges:
    count_per_bin, bin_edges = np.histogram(dataframe[column], bins=number_of_bins)

    # Display each histogram bin value count:
    y_max = image.get_ylim()[1]
    offset = y_max * 0.02

    for i in range(len(count_per_bin)):
        bin_center = (bin_edges[i] + bin_edges[i + 1]) / 2  # Calculate the center of each bin
        # Create and place the text which include the bin value counts:
        image.text(x=bin_center, y=count_per_bin[i] + offset, s=str(count_per_bin[i]), ha='center', va='bottom',
                   fontsize=10, color='black', rotation=90)

    # Draw whisker lines:
    if positive:
        plt.axvline(upper_whisker, color='red', linestyle='dashed', linewidth=1.5, label='Upper Whisker')
    else:
        upper_whisker = 0  # If not positive, the upper whisker should be set to 0
        plt.axvline(upper_whisker, color='red', linestyle='dashed', linewidth=1.5, label='Upper Whisker')
    if negative:
        plt.axvline(lower_whisker, color='orange', linestyle='dashed', linewidth=1.5, label='Lower Whisker')
    else:
        lower_whisker = 0  # If not negative, the lower whisker should be set to 0
        plt.axvline(lower_whisker, color='orange', linestyle='dashed', linewidth=1.5, label='Lower Whisker')

    # Display bin edge values on the x-axis:
    plt.xticks(bin_edges, rotation=90)

    plt.legend(loc='upper right')
    plt.title(f'Histogram of {column}', fontsize=14)
    plt.xlabel(f'{column}', fontsize=12)
    plt.ylabel('Frequency', fontsize=12)
    plt.show()


def month_components_calculation(dataframe, month_columns):
    """
        This function applies cyclical encoding to month columns in the dataframe.
        It creates two new columns for each input month column: one for the cosine component
        and one for the sine component of the cyclical encoding.

        Cyclical encoding is useful for transforming cyclical features (like months, days, hours)
        into a format that is more suitable for machine learning models, ensuring that the model
        can interpret the cyclical nature of the data (i.e., December is adjacent to January).

        Args:
        - dataframe (pandas.DataFrame): The dataframe containing the month columns to be encoded.
        - month_columns (list): A list of column names containing month values (1-12) to be encoded.

        Returns:
        - pandas.DataFrame: The dataframe with new columns `x_comp_<month_column>` and
                             `y_comp_<month_column>` added for each input month column.
        """
    for col in month_columns:
        # Apply cyclical encoding using cosine for the x-component of the encoding:
        dataframe[f'x_comp_{col}'] = np.cos(2 * np.pi * dataframe[col] / 12)

        # Apply cyclical encoding using sine for the y-component of the encoding:
        dataframe[f'y_comp_{col}'] = np.sin(2 * np.pi * dataframe[col] / 12)

    # Return the modified dataframe with the new columns
    return dataframe


def day_components_calculation(dataframe, year_columns, month_columns, day_columns):
    """
    This function applies cyclical encoding to day columns in the dataframe, taking into account
    different month lengths (31, 30, and 28/29 for February). It creates two new columns for each
    input day column: one for the cosine component and one for the sine component of the cyclical encoding.

    The cyclical encoding ensures that the model can interpret the cyclical nature of the day of the month,
    where the end of the month wraps around to the beginning.

    Args:
    - dataframe (pandas.DataFrame): The dataframe containing the day columns to be encoded.
    - year_columns (list): A list of column names containing the year values, used to determine leap years.
    - month_columns (list): A list of column names containing the month values (1-12).
    - day_columns (list): A list of column names containing the day values (1-31) to be encoded.

    Returns:
    - pandas.DataFrame: The dataframe with new columns `x_comp_<day_column>` and
                         `y_comp_<day_column>` added for each input day column.
    """

    # Define months with different lengths:
    months_with_31_days = [1, 3, 5, 7, 8, 10, 12]
    months_with_30_days = [4, 6, 9, 11]

    # Loop through each set of year, month, and day columns:
    for year, month, day in zip(year_columns, month_columns, day_columns):
        # Initialize new columns for x and y components of the cyclical encoding:
        dataframe[f'x_comp_{day}'] = np.nan
        dataframe[f'y_comp_{day}'] = np.nan

        # Create masks for each month length (31, 30, and February):
        mask_31 = dataframe[month].isin(months_with_31_days)
        mask_30 = dataframe[month].isin(months_with_30_days)
        mask_february = dataframe[month] == 2

        # Apply cyclical encoding for months with 31 days:
        dataframe.loc[mask_31, f'x_comp_{day}'] = np.cos(2 * np.pi * dataframe.loc[mask_31, day] / 31)
        dataframe.loc[mask_31, f'y_comp_{day}'] = np.sin(2 * np.pi * dataframe.loc[mask_31, day] / 31)

        # Apply cyclical encoding for months with 30 days:
        dataframe.loc[mask_30, f'x_comp_{day}'] = np.cos(2 * np.pi * dataframe.loc[mask_30, day] / 30)
        dataframe.loc[mask_30, f'y_comp_{day}'] = np.sin(2 * np.pi * dataframe.loc[mask_30, day] / 30)

        # Check for leap year:
        is_leap_year = dataframe[year].apply(lambda x: calendar.monthrange(x, 2)[1] == 29)

        # Apply cyclical encoding for February in leap years (29 days):
        dataframe.loc[mask_february & is_leap_year, f'x_comp_{day}'] = np.cos(
            2 * np.pi * dataframe.loc[mask_february & is_leap_year, day] / 29
        )
        dataframe.loc[mask_february & is_leap_year, f'y_comp_{day}'] = np.sin(
            2 * np.pi * dataframe.loc[mask_february & is_leap_year, day] / 29
        )

        # Apply cyclical encoding for February in non-leap years (28 days):
        dataframe.loc[mask_february & ~is_leap_year, f'x_comp_{day}'] = np.cos(
            2 * np.pi * dataframe.loc[mask_february & ~is_leap_year, day] / 28
        )
        dataframe.loc[mask_february & ~is_leap_year, f'y_comp_{day}'] = np.sin(
            2 * np.pi * dataframe.loc[mask_february & ~is_leap_year, day] / 28
        )

    # Return the modified dataframe with new cyclical day encoding columns:
    return dataframe
